/********************************************************************
 * FILE : orthocamera.C
 * 
 * Write both a pure virtual generic Camera class and an 
 * OrtographicCamera subclass. A camera must be able to generate a ray
 * for each screen-space coordinate, described as a Vec2f:
 *
 *      Ray generateRay(Vec2f point)
 *
 * The direction of the rays generated by an ortographic camera is 
 * always the same, but the origin varies.
 *
 * An ortographic camera is described by an orthonormal basis (one
 * point and three vectors) and an image size (one floating point).
 * The constructor takes as input the center of the image, the 
 * projection direction, an up vector, and the image size. The input 
 * projection direction might not be a unit vector and must be 
 * normalized. The input vector might not be a unit vector or 
 * perpendicular to the direction. It must be modified to be 
 * orthonormal to the direction. The third basis vector, the 
 * horizontal vector of the image plane, is deduced from the direction
 * and the up vector (hint: remember vector algebra and cross 
 * products). The origin of the rays generated by the camera for the 
 * screen coordinates, which vary from (0,0) -> (0,1), should bary 
 * from:
 *
 *          center - (size/2)up - (size/2)horizontal 
 *      to
 *          center + (size/2)up + (size/2)horizontal
 *
 * The camera does not know about screen resolution. Image resolution 
 * should be handled in your main loop. For non-square image ratios, 
 * just crop the screen coordinates accordingly.
 ********************************************************************/

#include "orthocamera.h"
#include "vectors.h"
#include "ray.h"

// Constructor
OrthographicCamera::OrthographicCamera(Vec3f &c, Vec3f &p, Vec3f &u,
                                       float sz) {
    size = sz;
    center = c;
    p.Normalize();
    projection = p;
    Vec3f::Cross3(horizontal, u, p);
    horizontal.Normalize();
    Vec3f::Cross3(up, p, horizontal);
}

// Destructor
OrthographicCamera::~OrthographicCamera() {}

// Getters and Setters
Vec3f OrthographicCamera::getCenter() { return center; }
void OrthographicCamera::setCenter(Vec3f &c) { center = c; }
Vec3f OrthographicCamera::getProjection() { return projection; }
void OrthographicCamera::setProjection(Vec3f &p) { projection = p; }
Vec3f OrthographicCamera::getUp() { return up; }
void OrthographicCamera::setUp(Vec3f &u) { up = u; }
Vec3f OrthographicCamera::getHorizontal() { return horizontal; }
void OrthographicCamera::setHorizontal(Vec3f &h) { horizontal = h; }
float OrthographicCamera::getSize() { return size; }
void OrthographicCamera::setSize(float sz) { size = sz; }

// Methods

/********************************************************************
 * FUNCTION : generateRay
 ********************************************************************/
Ray OrthographicCamera::generateRay(Vec2f point) {
    Vec3f tempH;
    Vec3f tempU;
    CopyScale(tempH, horizontal, point.x());
    CopyScale(tempU, up, point.y());
    Vec3f desp = tempU + tempH;
    Vec3f origin =  center + desp;
    
    return Ray(projection, origin);
}